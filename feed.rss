<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>/</link>
		<description />
		<copyright>Copyright © 2021</copyright>
		<pubDate>Tue, 09 Mar 2021 01:39:54 GMT</pubDate>
		<lastBuildDate>Tue, 09 Mar 2021 01:39:54 GMT</lastBuildDate>
		<item>
			<title>ASP.NET Web API Multi-Auth</title>
			<link>/posts/web-api-multi-auth</link>
			<description>&lt;p&gt;We are building an application that is to be used by our customers, but also some internal folks at our company. Since we are on office 365, we thought it made sense to have our internal team login using office 365. The external clients were setup using asp.net Identity aka local accounts.&lt;/p&gt;</description>
			<guid isPermaLink="false">/posts/web-api-multi-auth</guid>
			<pubDate>Fri, 05 Mar 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;We are building an application that is to be used by our customers, but also some internal folks at our company. Since we are on office 365, we thought it made sense to have our internal team login using office 365. The external clients were setup using asp.net Identity aka local accounts.&lt;/p&gt;
&lt;p&gt;Seting up the multiple authorizations is quite easy as it all happens inside the startup pipeline through the use of middleware. The Microsoft Identity platform has a very handy extension method for setting that up.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;services.AddAuthentication().AddMicrosoftIdentityWebApi(Configuration, &amp;quot;AzureAd&amp;quot;, &amp;quot;AzureAd&amp;quot;);`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second parmeter is the key of the configuration item in the &lt;code&gt;appsettings.json&lt;/code&gt; like so&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;&amp;quot;AzureAd&amp;quot;: {
    &amp;quot;Instance&amp;quot;: &amp;quot;https://login.microsoftonline.com/&amp;quot;,
    &amp;quot;Tenant&amp;quot;: &amp;quot;&amp;lt;your tenant name&amp;gt;&amp;quot;,
    &amp;quot;Audience&amp;quot;: &amp;quot;&amp;lt;the client id of the registered application within Azure&amp;gt;&amp;quot;,
    &amp;quot;TenantId&amp;quot;: &amp;quot;&amp;lt;your tenante id&amp;gt;&amp;quot;,
    &amp;quot;ClientId&amp;quot;: &amp;quot;&amp;lt;the client id of the registered application within Azure&amp;gt;&amp;quot;,
    &amp;quot;CallbackPath&amp;quot;: &amp;quot;/signin-oidc&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The third parameter is a name you give to this authentication scheme, which can later be utilized on the controllers or actions like so&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;    [Route(&amp;quot;[controller]&amp;quot;), ApiController, Authorize(AuthenticationSchemes = &amp;quot;AzureAd&amp;quot;)]
    public class MyController : BaseController
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for the local accounts, I was so inspired by the clean one line setup of the &lt;code&gt;AddMicrosoftIdentityWebApi extension&lt;/code&gt; method that I added my own in the same way&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;    services.AddLocalAuthorization(Configuration);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then I added my extension class like so&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;
public static class AuthenticationExtensions
    {
        public static IServiceCollection AddLocalAuthorization(
            this IServiceCollection serviceCollection,
            IConfiguration configuration)
        {
            serviceCollection
                .AddAuthorization(options =&amp;gt;
                {
                    options.AddLocalAuthPolicy();
                })
                .AddAuthentication(&amp;quot;LocalAccountsScheme&amp;quot;)
                .AddJwtBearer(&amp;quot;LocalAccountsScheme&amp;quot;,
                    options =&amp;gt;
                    {
                        options.TokenValidationParameters = new TokenValidationParameters()
                        {
                            ValidateIssuer = true,
                            ValidIssuer = configuration.GetSection(&amp;quot;TokenConfiguration&amp;quot;)[&amp;quot;Issuer&amp;quot;],
                            ValidateAudience = true,
                            ValidAudience = configuration.GetSection(&amp;quot;TokenConfiguration&amp;quot;)[&amp;quot;Audience&amp;quot;],
                            ValidateIssuerSigningKey = true,
                            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration.GetSection(&amp;quot;TokenConfiguration&amp;quot;)[&amp;quot;SecretKey&amp;quot;]))
                        };
                    });

            return serviceCollection;
        }

        private static AuthorizationOptions AddLocalAuthPolicy(this AuthorizationOptions options)
        {
            var policy = new AuthorizationPolicyBuilder()
                .AddAuthenticationSchemes(&amp;quot;LocalAccountsScheme&amp;quot;)
                .RequireAuthenticatedUser()
                .Build();

            options.AddPolicy(&amp;quot;LocalAccountsPolicy&amp;quot;, policy);
            return options;
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then the controllers are decorated the same way&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;    [Route(&amp;quot;[controller]&amp;quot;), ApiController, Authorize(AuthenticationSchemes = &amp;quot;LocalAccountsScheme&amp;quot;)]
    public class MyController : BaseController
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when the Bearer token is passed from the UI, the appropriate mechanism to validate the token is used based on the authentication scheme on the controller.&lt;/p&gt;
&lt;p&gt;One thing to remember when registering the application in Azure AD is to ensure it is setup as a SPA application and issues Id_Tokens. Without that, the UI application will not be able to get the JWT tokens from Azure AD.&lt;/p&gt;
&lt;p&gt;Happy coding.&lt;/p&gt;
&lt;p&gt;~Q&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Blazor WASM Application Settings</title>
			<link>/posts/blazor-wasm-appsettings</link>
			<description>&lt;p&gt;Recently, we had an opportunity to build a brand new application for a subset of our customers. It seemed like a perfect opportunity to try Blazor in a production setting as the application was not going to be too large (famous last words:)).&lt;/p&gt;</description>
			<guid isPermaLink="false">/posts/blazor-wasm-appsettings</guid>
			<pubDate>Fri, 05 Mar 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;Recently, we had an opportunity to build a brand new application for a subset of our customers. It seemed like a perfect opportunity to try Blazor in a production setting as the application was not going to be too large (famous last words:)).&lt;/p&gt;
&lt;p&gt;One of the things we had to figure out was how to determine environments within the Blazor Web Assembly application. The Blazor Web Assemlby project supports &lt;code&gt;appsettings.json&lt;/code&gt; files, which has to be created in the wwwroot folder inside the WASM project. When a request comes into the application, the appsettings.json file is sent as part of the first package that gets downloaded.&lt;/p&gt;
&lt;p&gt;&lt;img src="/file.png" alt="File"&gt;&lt;/p&gt;
&lt;p&gt;We had to figure out how to push the &lt;code&gt;appsettings.DEV.json&lt;/code&gt; and &lt;code&gt;appsettings.PRD.json&lt;/code&gt; files from our various environments. These files can have things like the environment specific API Url.&lt;/p&gt;
&lt;p&gt;By default, when we publish a WASM project, it generates a web.config inside the output folder, which has a bunch of things that allow for the WASM application to be served correctly. To setup the correct environment, we have to send a custom header named &lt;code&gt;blazor-environment&lt;/code&gt;. The WASM application then uses this to determine which &lt;code&gt;appsettings&lt;/code&gt; file to use.&lt;/p&gt;
&lt;p&gt;For instance in our case we ended up adding this to the generated web.config file during our publish process&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;httpProtocol&amp;gt;
    &amp;lt;customHeaders&amp;gt;
        &amp;lt;add name="blazor-environment" value="DEV" /&amp;gt;
    &amp;lt;/customHeaders&amp;gt;
&amp;lt;/httpProtocol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we add this, the appropriate &lt;code&gt;appsettings&lt;/code&gt; file is also pushed with the first download.&lt;/p&gt;
&lt;p&gt;&lt;img src="/file2.png" alt="File2"&gt;&lt;/p&gt;
&lt;p&gt;We added the default web.config into our WASM project and also added the specific &lt;code&gt;web.DEV.config&lt;/code&gt; and &lt;code&gt;web.PRD.config&lt;/code&gt;. We also updated the WASM csproj file to have the following target added and utilized the &lt;code&gt;Microsoft.DotNet.Xdt.Tools&lt;/code&gt; nuget package to perform our config transforms. We just had to edit our WASM csproj file like so.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Target Name="ApplyXdtConfigTransform" BeforeTargets="_TransformWebConfig"&amp;gt;
    &amp;lt;PropertyGroup&amp;gt;
      &amp;lt;_SourceWebConfig&amp;gt;$(MSBuildThisFileDirectory)Web.config&amp;lt;/_SourceWebConfig&amp;gt;
      &amp;lt;_XdtTransform&amp;gt;$(MSBuildThisFileDirectory)Web.$(Configuration).config&amp;lt;/_XdtTransform&amp;gt;
      &amp;lt;_TargetWebConfig&amp;gt;$(PublishDir)Web.config&amp;lt;/_TargetWebConfig&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;
    &amp;lt;Exec Command="dotnet xdt --source &amp;amp;quot;$(_SourceWebConfig)&amp;amp;quot; --transform &amp;amp;quot;$(_XdtTransform)&amp;amp;quot; --output &amp;amp;quot;$(_TargetWebConfig)&amp;amp;quot;" Condition="Exists('$(_XdtTransform)')" /&amp;gt;
  &amp;lt;/Target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...and that is pretty much it.&lt;/p&gt;
&lt;p&gt;Happy coding.&lt;/p&gt;
&lt;p&gt;~Q&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>